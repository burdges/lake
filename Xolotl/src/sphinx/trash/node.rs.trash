



/// Sphinx node curve25519 public key.
#[derive(Debug, Default, Clone, Copy, PartialEq, Eq, Hash)]
pub struct NodePublicKey(pub [u8; 32]);

/// Identifier for the current concenus 
pub struct ConcensusId(pub [u8; 32]);

/// XChaCha20 not-a-nonce for all packets with a given `NodePublicKey`
/// in a given `ConcensusId`.  Nodes should cache this with their
/// `NodePrivateKey` but clients may simply generate it when building
/// packets.
pub struct NodeToken(pub [u8; 24]);

impl NodeToken {
    pub fn generate(params: &SphinxParams, 
                    concensus: &ConcensusId, 
                    node: &NodePublicKey
      ) -> NodeToken {
        use crypto::digest::Digest;
        use crypto::sha3::Sha3;

        let mut nk = [0u8; 24];
        let mut sha = Sha3::sha3_512();

        sha.input(&concensus.0);
        sha.input(&node.0);
        sha.input_str(params.protocol_name);
        sha.input(&concensus.0);
        sha.input(&node.0);
        sha.result(&mut nk);
        sha.reset();
        NodeToken(nk)
    }
}


/*
    /// Sphinx `'static` runtime paramaters 
    params: &'static SphinxParams,
*/

pub trait NodeInfo {
}

pub struct NodePublic {
    pub public_key: NodePublicKey,

    pub token: NodeToken,

    ed25519: Signature,
}

pub struct NodePrivate {
    /// Sphinx `'static` runtime paramaters 
    params: &'static SphinxParams,

    token: NodeToken,

}





























        /// Sender identity claim.  We cannot authenticate this, but
        /// it simplifies processing the body.
        sender: SenderId,






/*






    /// Arrival of a SURB we created with the specified seed and concensus.
    ArrivalSeeded {
        epoch_id: EpochId,
        surb_seed: SurbSeed,
    },

    /// Arrival of a short lived SURB we created and archived to
    /// improve performance.
    ArrivalKnown,

    /// Arrival of a message for a local application besides
    ArrivalUnknown {
        application: AppId,
    },

















pub trait NodeInfo {
    // fn identify() -> [u8; 16];
    // fn signing_public() -> ed25519::PublicKey;
}

pub trait NodeDHInfo {
    // fn identify() -> [u8; 16];
    // fn signing_public() -> ed25519::PublicKey;
    fn dh_public(&self) -> Point;

    /// 
    fn token(&self) -> NodeToken;
}

pub struct NodeDHPublic {
    public: Point,
}

impl NodeInfo for NodePrivate {
    fn dh_public(&self) -> &Point { &self.dh_public }

    fn token(&self) -> NodeToken {
        NodeToken::generate(self.params,)
    }
}

pub struct NodePrivate {
    private: Scalar,
    token: NodeToken
}

impl NodeInfo for NodePrivate {
    fn dh_public(&self) -> Point {
    }

    fn token(&self) -> NodeToken {
    }
}

node.private
node.token

params: &'static SphinxParams, replayer: RC, 
nt: &NodeToken,  ss: &


    let alpha = alpha.decompress() ?;  // BadAlpha
    let ss: SphinxSecret = alpha.key_exchange(node.private);

    let mut hop = SphinxHop::new(params,replayer,&node.token,&ss);
    hop.verify_gamma(beta,surb,gamma) ?;  // InvalidMAC

    hop.xor_beta(beta)
*/



