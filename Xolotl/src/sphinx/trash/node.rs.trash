




        /// Sender identity claim.  We cannot authenticate this, but
        /// it simplifies processing the body.
        sender: SenderId,






/*






    /// Arrival of a SURB we created with the specified seed and concensus.
    ArrivalSeeded {
        epoch_id: EpochId,
        surb_seed: SurbSeed,
    },

    /// Arrival of a short lived SURB we created and archived to
    /// improve performance.
    ArrivalKnown,

    /// Arrival of a message for a local application besides
    ArrivalUnknown {
        application: AppId,
    },

















pub trait NodeInfo {
    // fn identify() -> [u8; 16];
    // fn signing_public() -> ed25519::PublicKey;
}

pub trait NodeDHInfo {
    // fn identify() -> [u8; 16];
    // fn signing_public() -> ed25519::PublicKey;
    fn dh_public(&self) -> Point;

    /// 
    fn token(&self) -> NodeToken;
}

pub struct NodeDHPublic {
    public: Point,
}

impl NodeInfo for NodePrivate {
    fn dh_public(&self) -> &Point { &self.dh_public }

    fn token(&self) -> NodeToken {
        NodeToken::generate(self.params,)
    }
}

pub struct NodePrivate {
    private: Scalar,
    token: NodeToken
}

impl NodeInfo for NodePrivate {
    fn dh_public(&self) -> Point {
    }

    fn token(&self) -> NodeToken {
    }
}

node.private
node.token

params: &'static SphinxParams, replayer: RC, 
nt: &NodeToken,  ss: &


    let alpha = alpha.decompress() ?;  // BadAlpha
    let ss: SphinxSecret = alpha.key_exchange(node.private);

    let mut hop = SphinxHop::new(params,replayer,&node.token,&ss);
    hop.verify_gamma(beta,surb,gamma) ?;  // InvalidMAC

    hop.xor_beta(beta)
*/



