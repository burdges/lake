


            } else if c @ Command::ArrivalSURB {..} = command {
                hop = SphinxKDF::new(params,&self.secret_node_token(),&ss)
                    .replay_check(IgnoreReplay).unwrap();  // No Replay from IgnoreReplay
                // *refs.gamma = r.gamma;
                // refs.verify_gamma(&hop) ?;  // InvalidMAC
                break; // No more information encoded in refs.beta


















    /// Compute the poly1305 MAC `Gamma` using the key found in a Sphinx key exchange.
    pub fn create_gamma(&self, beta: &[u8], surb: &[u8], mask: &GammaKey) -> Gamma {
        // According to the current API gamma_out lies in a buffer supplied
        // by our caller, so no need for games to zero it here.
        let mut gamma_out: Gamma = Default::default();

        let gamma_key = self.gamma_key.0;
        for (i,j) in self.gamma_key.iter_mut().zip(mask.0.iter()) { &i ^= j; }
        let mut poly = Poly1305::new(&gamma_key);
        // let mut poly = ClearOnDrop::new(&mut poly);
        poly.input(beta);
        poly.input(surb);
        poly.raw_result(&mut gamma_out.0);
        poly.reset();
        Ok(gamma_out)
    }

    /// Verify the poly1305 MAC `Gamma` given in a Sphinx packet.
    ///
    /// Requires both Beta and the SURB, but not the SURB log.  Also,
    /// requires several key masks with which to attempt verification,
    /// given as a slice `&[GammaKey]`. 
    ///
    /// If gamma verifies with any given mask, then returns the index
    /// of the that passing mask.  At most one mask should ever pass.
    /// If gamma verification fails for all masks, then returns an
    /// InvalidMac error.
    pub fn verify_gamma(&self, beta: &[u8], surb: &[u8],
      mut masks: &[GammaKey], gamma_given: &Gamma) -> SphinxResult<usize> {
        if masks.len() == 0 { masks = &[Default::default()] }
        let passed = usize::max_value();
        for (i,mask) in masks.iter().enumerate() {
            let gamma_found = self.create_gamma(&mask, beta, surb);
            // TODO: let gamma_found = ClearOnDrop::new(&gamma_found); ???
            passed = ::consistenttime::ct_select_usize(
                ::consistenttime::ct_u8_slice_eq(&gamma_given.0, &gamma_found.0),
                i,0
            );
        }
        if passed == usize::max_value() {
            Err( SphinxError::InvalidMac(self.error_packet_id) )
        } else { Ok(passed) }
    }



















    /// Derive our stream cipher keys and replay code.
    pub fn new<N: NodeInfo>(&node: N, ss: &SphinxSecret) -> SphinxKDF {
        use crypto::digest::Digest;
        use crypto::sha3::shake_256;

        let mut r = &mut [0u8; 32+32];  // ClearOnDrop
        let mut sha = Sha3::shake_256();
        sha.input(&ss.0);
        sha.input_str( "Sphinx" );
        sha.input(&node.token.0);
        sha.input_str( node.params.protocol_name );
        sha.input(&ss.0);
        sha.result(r);
        sha.reset();

        let (chacha_key,replay_code,chacha_nonce,_) = array_refs![r,32,16,12,4];
        SphinxKeys {
            params: self,
            packet_name: ReplayCode(*replay_code),
            chacha_nonce: *chacha_nonce,
            chacha_key: *chacha_key,
        }
    }





















/*
impl SphinxKDF {
    /// Initalize an IETF ChaCha20 stream cipher with our key and nonce.
    fn do_chacha(&self) -> ChaCha20 {
        ChaCha20::new_ietf(&self.chacha_key, &self.chacha_nonce)
    }
}
*/














/// Sphinx KDF results consisting of the replay code, poly1305 key
/// for our MAC gamma, and a nonce and key for the IETF Chacha20
/// stream cipher used for everything else in the header.
///
/// Notes: We could improve performance by using the curve25519 point 
/// derived in the key exchagne directly as the key for an XChaCha20
/// instance, which includes some mixing, and using chacha for the 
/// replay code and gamma key.  We descided to use SHA3's SHAKE256
/// mode so that we have more and different mixing. 
pub struct SphinxKeys {
    /// Sphinx `'static` runtime paramaters 
    params: &'static SphinxParams,

    domestic: SphinxKeyParts,

    foreign: SphinxKeyParts,
}

impl SphinxKeys {
    /// Replay code for replay attach protection.
    pub fn replay_code(&self) -> ReplayCode { self.domestic.replay_code() }

    /// IETF ChaCha20 12 byte nonce
    pub fn nonce(&self) -> [u8; 12] { self.foreign.nonce() }


    pub 
        let hop = SphinxHop {
            params: self.params,
            chunks: self.params.stream_chunks() ?,
            error_packet_id: self.replay_code.error_packet_id(),
            packet_name: Default::default(),
            gamma_key: Default::default(),
            stream: ChaCha20::new_ietf(&self.chacha_key, &self.chacha_nonce)
        }

}


impl SphinxParams {
    /// Run our KDF on a Sphinx secret and a node token to produce the
    /// replay code, poly1305 MAC key, and nonce and key for Chacha20.
    new_sphinx_hop(&'static self, ss: &SphinxSecret, node_token: &NodeToken) -> SphinxKDF {
        use crypto::digest::Digest;
        use crypto::sha3::shake_256;

        let mut r = &mut [0u8; 16+16+32+32];  // ClearOnDrop
        let mut sha = Sha3::shake_256();
        sha.input(&ss.0);
        sha.input(&node_token.0);
        sha.input_str( params.protocol_name );
        sha.input(&ss.0);
        sha.result(r);
        sha.reset();

        let (nonce,_,replay_code,key,gamma_key) = array_refs![r,12,4,16,32,32];
        SphinxKDF {
            params: params,
            replay_code: ReplayCode(*replay_code),
            gamma_key: GammaKey(*gamma_key),
            chacha_nonce: *nonce,
            chacha_key: *key,
        }
        
    }
}




















/*
impl KeyStream for SphinxHop {
    /// Allow 
    fn xor_read(&mut self, dest: &mut [u8]) -> Result<(), Error> {
        self.stream.xor_read(dest)
    }
}

#[inline(always)]
pub fn chacha_blocks(i: Length) -> Length {
    i/64 + 1  //  (if i%64==0 { 0 } else { 1 }) 
}

impl SeekableKeyStream for SphinxHop {
    /// Hide any keystream 
    fn seek_to(&mut self, byte_offset: u64) -> Result<(), Error> {
        let skip = 64*chacha_blocks(SphinxHop::NEW_OFFSET+LIONESS_KEY_SIZE);
        self.stream.seek_to(byte_offset + skip)
    }
}
*/








impl SphinxParams {
    pub make_header(alpha: AlphaBytes, gamma: Gamma)

    pub fn slice_header(packet: &[u8]) -> {
        ;
    }
}

impl Header {
    pub fn to_bytes() {
    }
}



























    /// Checks for packet replays using the suplied `ReplayChecker`.
    /// If none occur, then create the IETF ChaCha20 object to process
    /// the header. 
    ///
    /// Replay protection requires that `ReplayChecker::replay_check`
    /// returns `Err( SphinxError::Replay(hop.replay_code) )` when a
    /// replay occurs.
    ///
    /// You may however use `IgnoreReplay` as the `ReplayChecker` for 
    /// ratchet sub-hops  and for all subhops in packet creation. 
    pub fn replay_check<RC: ReplayChecker>(&self, replayer: RC) -> SphinxResult<SphinxHop> {
        replayer.replay_check(&self.replay_code) ?;

        let hop = SphinxHop {
            params: self.params,
            chunks: self.params.stream_chunks() ?,
            replay_code: Default::default(),
            error_packet_id: self.replay_code.error_packet_id(),
            packet_name: Default::default(),
            gamma_key: Default::default(),
            stream: ChaCha20::new_ietf(&self.chacha_key, &self.chacha_nonce)
        }

        let mut r = &mut [0u8; 64];
        self.stream.xor_read(r).unwrap();  // No KeystreamError::EndReached here.
        let (packet_name,replay_code,gamma_key) = array_refs![r,16,16,32];
        hop.packet_name = PacketName(*packet_name);
        hop.gamma_key = GammaKey(*gamma_key);

        Ok(hop)
    }






