
We should consider building a verification-of-benevolence system to 
make ourselves less vulnerable to denial of service attacks.

A benevolence token consists of a Curve25519 key pair benevolence_key
where the 64 byte private key is the result of a sha512 operation, 
ala an Ed25519 key, and perhaps additional data such as an algorithm id.

There is always an ambient value for which a benevolence_token
is being spent, so we implement a function to approve transactions 
that need not be referentially transperent.

	verifyBenevolence : (benevolence : BenevolenceToken)
	                    -> (m : ByteString) -> IO Bool

In practice, simple proof-of-work systems cannot deal with attacks 
becuase botnets are more patient than users.\cite{???}  If however
we wish to use proof-of-work then we might ask for a collision
of work_factor bits between 
	scrypt BenevolenceToken.key.pub 
and 
	scrypt $ m `xor` r 
where r is a global random number such as the sha512 of the date.

Another option might be a free Taler-like mint that blind signs
benevolence token keys so that the public key and signature together
give a token.  There is no need for servers to contact the mint
to invalidate a particular token since we're only trying to prevent
abuse.  A botnet could however collect the benevolence tokens in 
advance unless the mint rotates keys frequently.

We could shift both the benevolence algorithm itself and its work 
parameters dynamically depending upon network conditions.
In fact, we must do so because we do not know a really acceptable solution.



\begin{code}
message benevolence_token {
	required uint32	type = 1 ; 
	required bytes token = 2 ; 
}
\end{code}

	detachBenevolence : ByteString -> (BenevolenceToken,ByteSring)

	verifyAttachedBenevolence : ByteString -> IO (Maybe ByteSring)

	AttachBenevolenceToken : ByteString -> PrivateBenevolenceToken -> ByteString

	AttachBenevolenceResource : ByteString -> BenevolenceResource ByteString


