
\section{Bloom filter notifications}

Anonymously transports notifications given by an approximate time-stamp 
and a Bloom filter with meaningful-but-random keys.

Bloom filter notifications servers (BFNs) maintain a list of time-stamped 
Bloom filters (tsBfs) of a fixed size s, probably 1-16k.  

\subsection{Queries and Consolidation}

At a random intervals, again oberying a Poisson-like, distribution each 
BFN opens a dialog with another BNF to mutually consolodate their similar
Bloom filter collections with smilar timestamps, provided produce a
Bloom filter with too many bits set.

	consolodate x y = assert (popcount z < max_consolodate_pop) z
		where z.timestamp = (max x.timestamp y.timestamp) + random?
			  z.Bf = x.Bf `Bf.union` y.Bf
	}

I have not worked out the query or consolodation process yet, but
the issues include :

Ideally, users suspiciously ask about bloom filters they're seeking,
pinging different DHT nodes.  Are there points with high overlap and/or
do most keys overlap with some other keys?  Long term queries?

Can we maintain a only few connections with the BFN netowrk, as opposed 
to building new Tor circuts for new queries?  

Can we usefully optimize the bloom filter for the birthday paradox?  
I.e. users always have bits that overlap between their different
contact's ratchet states, giving them many query points. 

Can we make the algorithm be completely symetric?  How similar can
we make BFN servers and clients?  We could even go so far as asking 
that queries insert garbage, but that sounds hard.



These are notifications not semaphores but if anyone ever makes semaphores then
Bloomaphores sounds nice. 
